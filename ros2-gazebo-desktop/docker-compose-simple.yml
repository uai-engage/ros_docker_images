# Simplified Docker Compose for Development
# Single container with all features for local PX4/ArduPilot testing

services:
  ros2-dev:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        USERNAME: ${USERNAME:-rosuser}
        USER_UID: ${USER_UID:-1000}
        USER_GID: ${USER_GID:-1000}
    image: ros2-gazebo-desktop:jazzy-vnc-px4
    container_name: ${CONTAINER_NAME:-ros2_dev_station}

    stdin_open: true
    tty: true

    environment:
      - VNC_PASSWORD=${VNC_PASSWORD:-rospassword}
      - VNC_RESOLUTION=${VNC_RESOLUTION:-1920x1080}
      - VNC_DEPTH=${VNC_DEPTH:-24}
      - ROS_DOMAIN_ID=${ROS_DOMAIN_ID:-0}
      - RMW_IMPLEMENTATION=${RMW_IMPLEMENTATION:-rmw_fastrtps_cpp}
      # PX4 Gazebo models/worlds path (mounted from px4-sitl-container)
      - GZ_SIM_RESOURCE_PATH=/home/rosuser/px4_gazebo/models:/home/rosuser/px4_gazebo/worlds
      - GZ_PARTITION=${GZ_PARTITION:-gazebo}
      - GZ_RELAY=1
      - XDG_RUNTIME_DIR=/tmp/runtime-${USERNAME:-rosuser}
      # Gazebo rendering: ogre works better with software rendering than ogre2
      - GZ_SIM_RENDER_ENGINE_NAME=ogre
      # EGL Software Rendering (for VNC without GPU)
      # Option 1: Use software rendering (swrast)
      - LIBGL_ALWAYS_SOFTWARE=${LIBGL_ALWAYS_SOFTWARE:-0}
      - EGL_PLATFORM=surfaceless
      - EGL_DRIVER=swrast
      # Option 2: Or use llvmpipe for better performance
      - GALLIUM_DRIVER=llvmpipe
      - FASTRTPS_DEFAULT_PROFILES_FILE=/home/${USERNAME:-rosuser}/.ros/fastdds.xml

    volumes:
      # Built-in workspace (DO NOT MOUNT - contains micro-ROS agent, px4_msgs)
      # ~/ros2_ws inside container has pre-built packages

      # Development workspace (MOUNT YOUR CUSTOM PACKAGES HERE)
      # This overlays on top of built-in workspace using ROS 2 overlay feature
      # Your packages will have access to micro-ROS agent, MAVROS2, px4_msgs
      - ${DEV_WORKSPACE:-./dev_ws}:/home/${USERNAME:-rosuser}/dev_ws:rw

      # PX4 Gazebo models and worlds (shared with PX4 SITL container)
      # This allows Gazebo to load PX4 vehicle models (x500, rc_cessna, etc.)
      - ${PX4_GAZEBO_PATH:-./px4-sitl-container/PX4-Autopilot/Tools/simulation/gz}:/home/${USERNAME:-rosuser}/px4_gazebo:ro

      - /dev/shm:/dev/shm
      # Mount serial devices if needed
      - /dev:/dev

    # HOST NETWORK for ROS 2 DDS and PX4 communication
    # VNC: port 5901, noVNC: port 6080
    # micro-ROS: port 8888 (configurable)
    network_mode: host

    # Serial port access for hardware FC
    privileged: true

    shm_size: '2gb'
    ipc: host

    deploy:
      resources:
        limits:
          memory: 8G
        reservations:
          memory: 4G

    working_dir: /home/${USERNAME:-rosuser}/ros2_ws

    command: /startup-vnc.sh

# Usage:
# ======
#
# Build:
#   docker compose -f docker-compose-simple.yml build
#
# Start with explicit env file (recommended):
#   docker compose -f docker-compose-simple.yml --env-file .env up -d
#
# Or use default values (no env file):
#   docker compose -f docker-compose-simple.yml up -d
#
# Access VNC: http://localhost:6080/vnc.html
#
# ==============================================
# Running Gazebo with PX4 Models:
# ==============================================
#   1. Connect to ROS 2 container:
#      docker exec -it ros2_dev_station bash
#
#   2. Launch Gazebo with PX4 world:
#      gz sim -v4 -r ~/px4_gazebo/worlds/default.sdf
#
#      Available worlds:
#      - default.sdf (empty world)
#      - baylands.sdf (outdoor terrain)
#      - windy.sdf (with wind simulation)
#
#   3. The PX4 SITL will automatically spawn the vehicle when it connects
#
# Run micro-ROS agent (for PX4):
#   docker exec -it ros2_dev_station bash
#   micro-ros-agent udp4 -p 8888
#
# Or use MAVROS2 (for ArduPilot/PX4):
#   docker exec -it ros2_dev_station bash
#   ros2 launch mavros apm.launch fcu_url:=udp://:14550@
#
# Development Workspace (for your custom packages):
#   1. Create dev_ws on host: mkdir -p dev_ws/src
#   2. Create your package: cd dev_ws/src && ros2 pkg create my_package
#   3. Inside container:
#      cd ~/dev_ws
#      source ~/ros2_ws/install/setup.bash  # Source built-in packages first
#      colcon build
#      source install/setup.bash            # Source your packages
#   4. Now you have access to both micro-ROS agent AND your custom packages!
